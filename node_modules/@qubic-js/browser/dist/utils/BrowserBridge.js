"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const json_rpc_engine_1 = require("json-rpc-engine");
const core_1 = require("@qubic-js/core");
const eth_rpc_errors_1 = require("eth-rpc-errors");
class BrowserBridge extends events_1.EventEmitter {
    constructor(options) {
        super();
        // reason for partial is that id might not included in data
        this.send = data => {
            return new Promise((resolve, reject) => {
                const id = data.id || json_rpc_engine_1.getUniqueId();
                const payload = Object.assign({ id }, data);
                this.postMessage({
                    action: 'call_request',
                    payload,
                }, '*');
                this.callbacks.set(id, (error, response) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        // TODO: should refactor hide, hideIframe flow
                        // wait for hideIframe done
                        setTimeout(() => resolve(response), 0);
                    }
                });
            });
        };
        this.callbacks = new Map();
        this.postMessage = options.postMessage;
        options.listenMessageFrom.addEventListener('message', event => {
            try {
                // TODO: event.data.method event.data.action should be refactored
                const { method } = event.data;
                if (method === 'clear') {
                    this.emit(core_1.BridgeEvent.clear);
                    this.callbacks.forEach(callback => {
                        callback(eth_rpc_errors_1.ethErrors.provider.userRejectedRequest(), undefined);
                    });
                    this.callbacks.clear();
                    return;
                }
                if (method === 'setAddress') {
                    const { address } = event.data;
                    this.emit(core_1.BridgeEvent.accountsChanged, address ? [address] : []);
                    return;
                }
                if (method === 'setNetwork') {
                    this.emit(core_1.BridgeEvent.chainChanged, event.data.chainId);
                    return;
                }
                const { action } = event.data;
                if (action === 'ready') {
                    this.emit(core_1.BridgeEvent.ready);
                    return;
                }
                // TODO: renamed hideIframe to hide
                if (action === 'hideIframe') {
                    this.emit(core_1.BridgeEvent.hide);
                    this.callbacks.forEach(callback => {
                        callback(eth_rpc_errors_1.ethErrors.provider.userRejectedRequest(), undefined);
                    });
                    this.callbacks.clear();
                    return;
                }
                if (action === 'approve_request') {
                    const { id, result } = event.data;
                    const callback = this.callbacks.get(id);
                    if (callback) {
                        // Then resolve/reject the send promise
                        callback(undefined, result);
                        this.callbacks.delete(id);
                    }
                }
                if (action === 'reject_request') {
                    const { id, error } = event.data;
                    const callback = this.callbacks.get(id);
                    if (callback) {
                        // Then resolve/reject the send promise
                        const { code, message, data } = error;
                        callback(new eth_rpc_errors_1.EthereumRpcError(code, message, data), undefined);
                        this.callbacks.delete(id);
                    }
                }
            }
            catch (error) {
                console.error(`Parse json rpc error: ${event.data}`, event.data);
            }
        });
    }
}
exports.default = BrowserBridge;
