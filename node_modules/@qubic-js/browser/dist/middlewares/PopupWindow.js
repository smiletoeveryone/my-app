"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const eth_rpc_errors_1 = require("eth-rpc-errors");
const json_rpc_engine_1 = require("json-rpc-engine");
const core_1 = require("@qubic-js/core");
const translation_1 = require("../translation");
const BrowserBridge_1 = __importDefault(require("../utils/BrowserBridge"));
const Modal_1 = __importDefault(require("../ui/Modal"));
const DETECT_IF_POPUP_WINDOW_CLOSED_INTERVAL_MS = 500;
class PopupWindow {
    constructor(walletUrl, apiConfig) {
        this.isReady = false;
        this.proxy = null;
        this.getUrl = () => {
            return core_1.urlWithApiConfig(this.walletUrl, this.apiConfig);
        };
        this.detectCloseEventTimer = 0;
        this.detectPopupWindowCloseEvent = (proxy) => {
            // this.proxy.onclose event can't works with cross domain
            // based on https://stackoverflow.com/questions/9388380/capture-the-close-event-of-popup-window-in-javascript
            window.clearInterval(this.detectCloseEventTimer);
            if (proxy) {
                this.detectCloseEventTimer = window.setInterval(() => {
                    if (proxy.closed) {
                        clearInterval(this.detectCloseEventTimer);
                        // in general, action:hideIframe is coming from popup window
                        // if user closed popup window via browser, sdk need to be informed with that action
                        window.postMessage({
                            action: 'hideIframe',
                        }, '*');
                    }
                }, DETECT_IF_POPUP_WINDOW_CLOSED_INTERVAL_MS);
            }
        };
        this.openPopupWindow = () => {
            if (!this.proxy || this.proxy.closed) {
                const target = 'qubic-wallet';
                const windowFeatures = 'location=no,resizable=yes,scrollbars=yes,status=yes,height=680,width=350';
                const proxy = window.open(this.getUrl(), target, windowFeatures);
                this.detectPopupWindowCloseEvent(proxy);
                this.proxy = proxy;
                return proxy;
            }
            return null;
        };
        this.hide = () => {
            this.newWindowReminderModal.hide();
            if (this.proxy && !this.proxy.closed) {
                this.proxy.close();
                this.proxy = null;
                this.isReady = false;
            }
        };
        this.show = (options) => {
            if (this.proxy && !this.proxy.closed && this.isReady) {
                return;
            }
            // some action is quick enough, we can open window immediately
            const tryOpenWindow = this.openPopupWindow();
            // if tryOpenWindow failed, we will show the confirm box, let user open popup manually
            if (!tryOpenWindow) {
                this.newWindowReminderModal.show({
                    onCancel: options.onReminderModalCancel,
                });
            }
        };
        this.waitUntilReady = () => {
            const { bridge, proxy, isReady, show } = this;
            return new Promise((resolve, reject) => {
                if (proxy && !proxy.closed && isReady) {
                    resolve();
                    return;
                }
                bridge.once(core_1.BridgeEvent.ready, resolve);
                show({
                    onReminderModalCancel: () => {
                        bridge.removeListener(core_1.BridgeEvent.ready, resolve);
                        reject();
                    },
                });
            });
        };
        this.createPrepareBridgeMiddleware = () => json_rpc_engine_1.createAsyncMiddleware((req, res, next) => __awaiter(this, void 0, void 0, function* () {
            if (core_1.WALLET_HANDLE_METHODS.includes(req.method)) {
                try {
                    yield this.waitUntilReady();
                }
                catch (error) {
                    res.error = eth_rpc_errors_1.ethErrors.provider.userRejectedRequest();
                }
            }
            next();
        }));
        this.walletUrl = walletUrl;
        this.apiConfig = apiConfig;
        this.newWindowReminderModal = new Modal_1.default({
            description: translation_1.t('popup-window-hint'),
            cancelText: translation_1.t('no'),
            onCancel: () => {
                window.postMessage({
                    action: 'hideIframe',
                }, '*');
            },
            confirmText: translation_1.t('yes'),
            onConfirm: () => {
                this.openPopupWindow();
            },
            hideWhenConfirm: true,
        });
        document.body.appendChild(this.newWindowReminderModal.element);
        this.bridge = new BrowserBridge_1.default({
            postMessage: (message, targetOrigin, transfer) => {
                var _a;
                (_a = this.proxy) === null || _a === void 0 ? void 0 : _a.postMessage(message, targetOrigin, transfer);
            },
            listenMessageFrom: window,
        });
        this.bridge.on(core_1.BridgeEvent.ready, () => {
            this.isReady = true;
        });
        this.bridge.on(core_1.BridgeEvent.hide, () => {
            this.hide();
        });
    }
}
exports.default = PopupWindow;
